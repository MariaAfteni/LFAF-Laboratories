#  Chomsky Normal Form

### Course: Formal Languages & Finite Automata
### Author: Afteni Maria

----

## Theory:
&ensp;&ensp;&ensp;The Chomsky normal form is a way to represent a context-free grammar in a specific form that simplifies
its structure and makes it easier to analyze. In Chomsky normal form, all productions have one of two forms: either a 
single terminal symbol, or a pair of nonterminal symbols. Additionally, the start symbol must have at least one production 
that generates a single terminal symbol. By ensuring that all productions are in this form, Chomsky normal form makes it 
possible to perform certain analyses on the grammar, such as determining whether it is ambiguous or deciding whether a 
string can be generated by the grammar. Converting a context-free grammar to Chomsky normal form can be done using a set
of well-defined rules that manipulate the productions of the grammar.

## Objectives:
1. Learn about Chomsky Normal Form (CNF).
2. Get familiar with the approaches of normalizing a grammar.
3. Implement a method for normalizing an input grammar by the rules of CNF.
    1. The implementation needs to be encapsulated in a method with an appropriate signature (also ideally in an appropriate class/type).
    2. The implemented functionality needs executed and tested.
    3. A BONUS point will be given for the student who will have unit tests that validate the functionality of the project.
    4. Also, another BONUS point would be given if the student will make the aforementioned function to accept any grammar, 
   not only the one from the student's variant.

## Implementation description:
&ensp;&ensp;&ensp; The goal of this laboratory work was to normalize the given grammar using the Chomsky Normal Form. To 
do so, the first step is to exclude all epsilon transitions. For this I used the `noEpsilon` method:

    public ArrayList<String> noEpsilon(){
    ArrayList<String> noEpsilon = new ArrayList<>(); // Stores new productions after eliminating epsilon

        // Iterate through each production and check for epsilon
        for (String prod : Production) {
            String[] vt = prod.split(">");
            if (!vt[1].equals("ε")) {
                noEpsilon.add(prod);

            }
        }
        return noEpsilon;
    }
&ensp;&ensp;&ensp; The method takes in a set of productions and returns a new set with epsilon productions removed. I use an 
ArrayList to store the new productions after elimination. The method iterates through each production in the given set and 
checks if the right-hand side of the production contains "ε". If the right-hand side is not "ε", the production is 
added to the new set without any modification. Otherwise, if the right-hand side is "ε", the production is skipped 
and not added to the new set. Finally, the method returns the new set of productions without epsilon transitions.

&ensp;&ensp;&ensp; The next step is to exclude any renaming transitions. A renaming transitions of form "A->B" in which
a non-terminal symbol transitions in another non-terminal symbol. To do so I used the `noRenaming` method.

    public ArrayList<String> noRenaming(ArrayList<String> Prod){
        ArrayList<String> noRenaming = new ArrayList<>(); // Stores new productions after eliminating epsilon
        for (String prod : Prod) {
            String[] vt = prod.split(">");

            if (!(vt[1].length() == 1 && vt[1].toCharArray()[0] >= 'A' && vt[1].toCharArray()[0] <= 'Z')) {
                noRenaming.add(prod);
            }
        }
        return noRenaming;
    }

&ensp;&ensp;&ensp;The method uses an ArrayList to store the new productions after elimination. It iterates through each 
production in the given set and checks if the right-hand side of the production contains a single non-terminal symbol, 
represented as a character in the range 'A' to 'Z'. If the right-hand side contains more than one symbol, or if it 
contains a single symbol that is not a non-terminal symbol, the production is added to the new set without any modification. 
Otherwise, if the right-hand side contains a single non-terminal symbol, the production is skipped and not added to the 
new set. Finally, the method returns the new set of productions without renaming productions.

&ensp;&ensp;&ensp; Next, I needed to eliminate all the inaccessible transitions. Inaccessible non-terminal symbols are 
symbols that cannot be reached from the start symbol of the grammar.

    public ArrayList<String> noInaccessible(ArrayList<String> Prod){
        ArrayList<String> noInaccessible = new ArrayList<>();
        ArrayList<String> vn = new ArrayList<>();
        for(String prod: Prod){
            String[] vt = prod.split(">");
            String[] sym = vt[1].split("(?!^)");
            for (String s : sym) {
                if (s.toCharArray()[0] >= 'A' && s.toCharArray()[0] <= 'Z' && !vn.contains(s)) {
                    vn.add(s);
                }
            }

        }
        for(String prod: Prod){
            String[] vt = prod.split(">");
            String[] ac = vt[0].split("(?!^)");
            if(vn.contains(ac[0])){
                noInaccessible.add(prod);
            }
        }

        return noInaccessible;
    }
&ensp;&ensp;&ensp;The method `noInaccessible` iterates through each production in the given set and adds any non-terminal 
symbols in the right-hand side of the production to the list of reachable symbols if they are not already present. Then, 
it iterates through the productions again and checks if the left-hand side of the production is a reachable symbol. If 
it is, the production is added to the new set without any modification. Otherwise, the production is skipped and not 
added to the new set. Finally, the method returns the new set of productions without inaccessible productions.

&ensp;&ensp;&ensp;The last modification before is possible to normalize the grammar by Chomsky normal form, is to eliminate 
non-productive transitions. Nonproductive productions are productions that cannot produce any terminal symbols,  
they do not contribute to the language generated by the grammar.

    public ArrayList<String> noNonproductive(ArrayList<String> Prod){
        ArrayList<String> noNonproductive = new ArrayList<>();

        for(String prod: Prod){
            String[] vt = prod.split(">");
            String[] sym = vt[1].split("(?!^)");
            String[] ac = vt[0].split("(?!^)");
            int up = 0;
            String upper = "";
            for(String s : sym){
                if (s.toCharArray()[0] >= 'A' && s.toCharArray()[0] <= 'Z' ) {
                    up++;
                    upper = upper + s;
                }
            }
            if(up >= 2 || (up == 1 && !upper.equals(ac[0])) || up == 0){
                noNonproductive.add(prod);
            }
        }
&ensp;&ensp;&ensp;The method `noNonproductive` iterates through each production in the given set and checks if the 
production is productive or not. A production is considered productive if it has at least one non-terminal symbol in its 
right-hand side that is also present in the left-hand side, or if it has no non-terminal symbols in its right-hand side. 
Otherwise, the production is considered nonproductive and is skipped.

&ensp;&ensp;&ensp;Lastly, I created th `normalForm` method, that returns an ArrayList with the final normalized production.

    public ArrayList<String> normalForm(ArrayList<String> Prod){
        ArrayList<String> normalForm = new ArrayList<>();
        String[] sub = {"X1", "X2", "X3", "X4", "X5", "X6", "X7", "X8", "X9"};
        int i = 0;
        for(String prod: Prod) {
            String[] vt = prod.split(">");
            String[] sym = vt[1].split("(?!^)");
            String[] ac = vt[0].split("(?!^)");
            int up = 0;
            String upper = "";
            int lo = 0;
            String lower = "";
            for (String s : sym){
                if (s.toCharArray()[0] >= 'A' && s.toCharArray()[0] <= 'Z' ) {
                    up++;
                    if(up <= 2){
                        upper = upper + s;
                    }
                }
                else {
                    lo++;
                    if(lo <= 2){
                        lower = lower + s;
                    }
                }
            }
            if (sym.length == 1 || (up == 2 && sym.length == 2)){
                normalForm.add(prod);
            }
            else if(upper.length() == 2 && sym.length>2){
                normalForm.add(sub[i] + "->" + upper);
                normalForm.add(ac[0] + "->" + sub[i] + sym[sym.length-1]);
                i++;
            }
            else if(lower.length()==2 && sym.length>2){
                normalForm.add(sub[i] + "->" + lower);
                normalForm.add(ac[0] + "->" + sub[i] + sym[sym.length-1]);
                i++;
            }
            else if(lo == 1 && up == 1 && sym.length == 2){
                normalForm.add(sub[i] + "->" + lower);
                normalForm.add(ac[0] + "->" + sub[i] + upper);
                i++;
            }

        }
        return normalForm;

    }

&ensp;&ensp;&ensp;The method applies a series of transformations to the original productions. Specifically, it 
checks each production to see if it is already in Chomsky Normal Form, or if it needs to be transformed to meet the 
criteria. The method creates new productions, using intermediate variables represented by strings "X1" to "X9", as 
needed to meet the criteria for Chomsky Normal Form.

## Conclusions / Results
&ensp;&ensp;&ensp;The output is of form:

      Final production with no epsilon transitions:
      S->aB
      S->AC
      A->a
      A->ASC
      A->BC
      A->aD
      B->b
      B->bS
      C->BA
      E->aB
      D->abC
      -----------------------------------------------------
      Final production with no renaming transitions:
      S->aB
      S->AC
      A->a
      A->ASC
      A->BC
      A->aD
      B->b
      B->bS
      C->BA
      E->aB
      D->abC
      -----------------------------------------------------
      Final production with no inaccessible symbols:
      S->aB
      S->AC
      A->a
      A->ASC
      A->BC
      A->aD
      B->b
      B->bS
      C->BA
      D->abC
      -----------------------------------------------------
      Final production with no nonproductive transitions:
      S->aB
      S->AC
      A->a
      A->ASC
      A->BC
      A->aD
      B->b
      B->bS
      C->BA
      D->abC
      -----------------------------------------------------
      Chomsky Normal Form Production
      X1->a
      S->X1B
      S->AC
      A->a
      X2->AS
      A->X2C
      A->BC
      X3->a
      A->X3D
      B->b
      X4->b
      B->X4S
      C->BA
      X5->ab
      D->X5C
      
      Process finished with exit code 0

&ensp;&ensp;&ensp;During this laboratory, I have implemented several methods in Java to normalize a given grammar. I started by eliminating
epsilon productions, followed by eliminating renaming productions, then eliminating inaccessible productions, and finally 
eliminating nonproductive productions. I also implemented a method to convert a given grammar to Chomsky normal form.

&ensp;&ensp;&ensp;Overall, this laboratory helped me gain a better understanding of formal language theory and its practical applications in software engineering.

